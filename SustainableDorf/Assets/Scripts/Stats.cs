using UnityEngine;

public class Stats : MonoBehaviour
{
    // checks position when spawning to allow placing the tile back if not wanted 
    // used in Jans "PutSelectedTileBack"-Script
    public Vector3 myPosition;

    // one-time stats generated randomly for every new tile
    public float prosperityStat;
    public float happinessStat;
    public float environmentStat;

    // these are used to determine the value of the stats
    float randomFloat; // technically this is now == to mainStat
    public float mainStat;
    public float randomStat1;
    public float randomStat2;

    // used to decide when to play "mooh"-sound
    public bool isCow = false;
    public int numberOfCows;
    // currently unused bools:
    public bool isFactory = false;
    public bool isForest = false;
    public bool isSchool = false;
    public bool isKlaerwerk = false;

    // important as it declares which tiles NOT to destroy
    public bool wasPlaced = false;

    // these are generated by the Neighbor-Effect
    public float prosperityBonus = 0f;
    public float happinessBonus = 0f;
    public float environmentBonus = 0f;

    // used in UpdateStats() to update overall degeneration rate with this factor
    private float degenerationFactor;

    // the amount of influence neighbors have on eachothers Stats
    float positiveInfluence = -.001f;
    float neutralInfluence = 0f;
    float negativeInfluence = .001f;
    
    // used to get easy access to any of the core scripts on the SceneManager GameObject
    GameObject sceneManager;

    // randomize Stats of a tile AND its rotation on the platform
    public void RandomizeStats(GameObject tile, Vector3 position)
    {
        // checks position when spawning to allow placing the tile back if not wanted
        myPosition = position;

        sceneManager = GameObject.Find("SceneManager");

        positiveInfluence = sceneManager.GetComponent<GameManager>().positiveInfluence;
        neutralInfluence = sceneManager.GetComponent<GameManager>().neutralInfluence;
        negativeInfluence = sceneManager.GetComponent<GameManager>().negativeInfluence;

        randomFloat = Random.Range(sceneManager.GetComponent<GameManager>().minStatsPerTile, sceneManager.GetComponent<GameManager>().maxStatsPerTile);

        mainStat = randomFloat;
        randomStat1 = randomFloat * Random.Range(-.5f, .5f); // second multiplyer to allow negative outcome
        randomStat2 = randomFloat * Random.Range(-.5f, .5f); // second multiplyer to allow negative outcome

            // this prevents all stats from being positive or the same
            // may need to be cancelled for new social stats
            if (randomStat1 >= 0f && randomStat2 >= 0f | randomStat1 == randomStat2)
            {
                int randomStat = Random.Range(1, 2);
                if (randomStat == 1)
                {
                    randomStat1 *= -1;
                }else
                {
                    randomStat2 *= -1;
                }
            }

        // stats are generated depending on tile-tag
        if (CompareTag("factory"))
        {
            prosperityStat = mainStat * Random.Range(.1f, 1f);
            happinessStat = randomFloat * Random.Range(-.5f, -0.1f); // factorys always cost space
            environmentStat = randomFloat * Random.Range(-.5f, -0.1f); // factorys always cost environment

            // old:
            //prosperityStat = mainStat;
            //happinessStat = randomStat1;
            //environmentStat = randomFloat * -1 /*Random.Range(-1f, 0f)*/; // factorys always cost environment
        }
        else if (CompareTag("nature"))
        {
            prosperityStat = randomFloat * Random.Range(-.5f, -0.1f); // nature always costs money
            happinessStat = randomFloat * Random.Range(-.5f, -0.1f); // nature always costs space
            environmentStat = mainStat * Random.Range(.1f, 1f);

            // old:
            //prosperityStat = randomFloat * Random.Range(-1f, -0.5f); // nature always costs money
            //happinessStat = randomFloat * Random.Range(0f, .5f); // nature always makes people happy
            //environmentStat = mainStat;
        }
        else if (CompareTag("social"))
        {
            prosperityStat = randomFloat * Random.Range(-.5f, -0.1f); // livingSpace always costs money
            happinessStat = mainStat * Random.Range(.1f, 1f);
            environmentStat = randomFloat * Random.Range(-.5f, -0.1f); // livingSpace always costs money
            
            // old:
            //prosperityStat = randomFloat * Random.Range(-1f, -0.5f); // social always costs money
            //happinessStat = mainStat;
            //environmentStat = randomStat2;
        }
        else if (CompareTag("sustainable"))
        {
            prosperityStat = randomStat2 * Random.Range(.1f, 1.5f);
            happinessStat = randomFloat * Random.Range(-.5f, -0.1f); // sustainable always costs space
            environmentStat = randomFloat * Random.Range(0f, .5f); // sustainability always aims to improve the environment

            // old:
            //prosperityStat = randomStat2;
            //happinessStat = randomStat1;
            //environmentStat = randomFloat * Random.Range(0f, .5f); // sustainability always aims to improve the environment
        }
    }

    // called when placing tile to transmit Stats
    // called in Jans "PlaceObjectsOnGrid"-Script
    public void UpdateStats()
    {
        // this bool tells the "TileGenerator"-script NOT to destroy a placed tile
        wasPlaced = true;
        //sceneManager.GetComponent<GameManager>().hoverInfoEnabled = true; // allready in PlaceObjectsOnGrid


        // this Counter works in connection with a timer to increase game difficulty over time
        sceneManager.GetComponent<NeedsManager>().tileCounter += 1;

        degenerationFactor = sceneManager.GetComponent<GameManager>().degenerationFactor;

        sceneManager.GetComponent<NeedsManager>().prosperityValue += prosperityStat;
        if (sceneManager.GetComponent<NeedsManager>().prosperityValue > 10f)
        {
            sceneManager.GetComponent<NeedsManager>().prosperityValue = 10f;
        }
        sceneManager.GetComponent<NeedsManager>().environmentValue += environmentStat;
        if (sceneManager.GetComponent<NeedsManager>().environmentValue > 10f)
        {
            sceneManager.GetComponent<NeedsManager>().environmentValue = 10f;
        }
        sceneManager.GetComponent<NeedsManager>().happinessValue += happinessStat;
        if (sceneManager.GetComponent<NeedsManager>().happinessValue > 10f)
        {
            sceneManager.GetComponent<NeedsManager>().happinessValue = 10f;
        }

        // the "* degenerationFactor" takes the static xStats and multiplies them with the degenerationFactor from the Game Manager, effectively creating a contineous influnece that is 1% of the static value
        // a degenerationFactor of .0001 = .01 % of static x 50 per secon. .0001 of (ex.) 3 would be 0.015 per second and 1 full unit every 66.6 seconds
        sceneManager.GetComponent<NeedsManager>().prosperityDegenerationRate -= prosperityStat * degenerationFactor;
        sceneManager.GetComponent<NeedsManager>().environmentDegenerationRate -= environmentStat * degenerationFactor;
        sceneManager.GetComponent<NeedsManager>().happinessDegenerationRate -= happinessStat * degenerationFactor;

        // calls function to destory leftover tiles in "TileGenerator"-script & loads new ones
        // this used to be part of BOTH above IF statements. if this works - delete THIS comment (!!!)
        sceneManager.GetComponent<TileGenerator>().DestroyRemainingTiles();
        sceneManager.GetComponent<TileGenerator>().NextSet();
        return;
    }


    // beginning of neighbor-effects:
    public void NeighborEffect(int factoryNeighbors, int socialNeighbors, int natureNeighbors, int sustainableNeighbors)
    {
        if (CompareTag("factory"))
        {
            prosperityBonus = ((float)factoryNeighbors * positiveInfluence) + ((float)socialNeighbors * positiveInfluence) + ((float)natureNeighbors * neutralInfluence) + ((float)sustainableNeighbors * negativeInfluence);
            happinessBonus = ((float)factoryNeighbors * neutralInfluence) + ((float)socialNeighbors * negativeInfluence) + ((float)natureNeighbors * negativeInfluence) + ((float)sustainableNeighbors * neutralInfluence);
            environmentBonus = ((float)factoryNeighbors * negativeInfluence) + ((float)socialNeighbors * neutralInfluence) + ((float)natureNeighbors * negativeInfluence) + ((float)sustainableNeighbors * positiveInfluence);
        }
        else if (CompareTag("nature"))
        {
            prosperityBonus = ((float)factoryNeighbors * neutralInfluence) + ((float)socialNeighbors * neutralInfluence) + ((float)natureNeighbors * negativeInfluence) + ((float)sustainableNeighbors * negativeInfluence);
            happinessBonus = ((float)factoryNeighbors * negativeInfluence) + ((float)socialNeighbors * positiveInfluence) + ((float)natureNeighbors * positiveInfluence) + ((float)sustainableNeighbors * positiveInfluence);
            environmentBonus = ((float)factoryNeighbors * negativeInfluence) + ((float)socialNeighbors * negativeInfluence) + ((float)natureNeighbors * positiveInfluence) + ((float)sustainableNeighbors * positiveInfluence);
        }
        else if (CompareTag("social")) // now: verfügbare Wohnfläche
        {
            prosperityBonus = ((float)factoryNeighbors * positiveInfluence) + ((float)socialNeighbors * negativeInfluence) + ((float)natureNeighbors * neutralInfluence) + ((float)sustainableNeighbors * positiveInfluence);
            happinessBonus = ((float)factoryNeighbors * negativeInfluence) + ((float)socialNeighbors * positiveInfluence) + ((float)natureNeighbors * positiveInfluence) + ((float)sustainableNeighbors * negativeInfluence);
            environmentBonus = ((float)factoryNeighbors * neutralInfluence) + ((float)socialNeighbors * neutralInfluence) + ((float)natureNeighbors * negativeInfluence) + ((float)sustainableNeighbors * neutralInfluence);
        }
        else if (CompareTag("sustainable"))
        {
            prosperityBonus = ((float)factoryNeighbors * negativeInfluence) + ((float)socialNeighbors * positiveInfluence) + ((float)natureNeighbors * negativeInfluence) + ((float)sustainableNeighbors * positiveInfluence);
            happinessBonus = ((float)factoryNeighbors * neutralInfluence) + ((float)socialNeighbors * negativeInfluence) + ((float)natureNeighbors * positiveInfluence) + ((float)sustainableNeighbors * positiveInfluence);
            environmentBonus = ((float)factoryNeighbors * positiveInfluence) + ((float)socialNeighbors * neutralInfluence) + ((float)natureNeighbors * positiveInfluence) + ((float)sustainableNeighbors * positiveInfluence);
        }

        GameObject StatsDisplay = GameObject.Find("Stats_UI");
        if (sceneManager.GetComponent<GameManager>().hoverInfoEnabled == false)
        {
            StatsDisplay.GetComponentInParent<StatUIDisplay>().CastNeighborEffectToUI(prosperityStat, happinessStat, environmentStat, prosperityBonus, happinessBonus, environmentBonus);
        }
    }

    public void AddNeighborBonus()
    {
        // this applies neighborBonus as a static value + or - of their already generated stats
        //-------------------------------------------------------------------------
        Debug.Log("prosperityStat = " + prosperityStat + " + prosperityBonus = " + prosperityBonus); // test
            prosperityStat += prosperityBonus;
        Debug.Log("new prosperityStat == " + prosperityStat); // test

        Debug.Log(" happinessStat = " + happinessStat + " + happinessBonus = " + happinessBonus); // test
            happinessStat += happinessBonus;
        Debug.Log("new happinessStat == " + happinessStat); // test

        Debug.Log("environmentStat = " + environmentStat + " + environmentBonus = " + environmentBonus); // test
            environmentStat += environmentBonus;
        Debug.Log("new environmentStat == " + environmentStat); // test


        // cows and neighbor-efficiency are counted and communicated here
        GameObject SceneManager = GameObject.Find("SceneManager");
        SceneManager.GetComponent<NeedsManager>().efficientlyPlaced += prosperityBonus + happinessBonus + environmentBonus;
        if (isCow)
        {
            SceneManager.GetComponent<NeedsManager>().cowCounter += numberOfCows;
        }
        //Debug.Log("current total efficientlyPlaced-bonus: " + SceneManager.GetComponent<NeedsManager>().efficientlyPlaced);
    }
}





// add the one-time stats of a tile with its neighbor-effects and add them once to the NEEDSMANAGER
// this is the basis to derive the contineous influence (10% of the one-time-stats)
/*Debug.Log("prosperityStat = " + prosperityStat + " + prosperityBonus = " + prosperityBonus); // test
prosperityStat += prosperityBonus;
Debug.Log("new prosperityStat == " + prosperityStat); // test

Debug.Log(" happinessStat = " + happinessStat + " + happinessBonus = " + happinessBonus); // test
happinessStat += happinessBonus;
Debug.Log("new happinessStat == " + happinessStat); // test

Debug.Log("environmentStat = " + environmentStat + " + environmentBonus = " + environmentBonus); // test
environmentStat += environmentBonus;
Debug.Log("new environmentStat == " + environmentStat); // test*/




//StatsDisplay.GetComponentInParent<StatUIDisplay>().CastNeighborEffectToUI(sceneManager.GetComponent<PlaceObjectsOnGrid>().curObject, prosperityBonus, happinessBonus, environmentBonus);

// hier kann man es anzeigen lassen:
//--> cast to UI, die Stats von curObj aus PlaceObjOn Grid abholen +die neighboreffect
// muss man immer zurücksetzen! --> problem: differenz von neighbor/ohne neighbor wird nicht klar. man braucht 
// 2 sets von anzeigen!  
// new set of anzeigen die hinter den HAUPT anzeigen liegen und NUR den enighboreffect anzeigen 
/*if (SceneManager.GetComponent<GameManager>().usingContinuousValues)
{
    SceneManager.GetComponent<NeedsManager>().prosperityDegenerationRate += prosperityBonus;
    SceneManager.GetComponent<NeedsManager>().environmentDegenerationRate += environmentBonus;
    SceneManager.GetComponent<NeedsManager>().happinessDegenerationRate += happinessBonus;
}*/


// depending on if a stat is pos. or neg. the bonus will be multiplied with the static on a 10% basis.
// ex: base value 1.7 * (1 + bonus .2) = new value 2.04, as a 20% bonus was applied
// ex: base value -1.9 * (1 + (-1 * bonus .2)) = new value -1.52, as a 20% bonus was applied
// this applies neighborBonus as 10% + or - of their already generated stats
//-------------------------------------------------------------------------
/*//Debug.Log("prosperityStat = " + prosperityStat + " + prosperityBonus = " + prosperityBonus); // test
if (prosperityStat >= 0)
{
    prosperityStat = prosperityStat * (1 + prosperityBonus);
}else
{
    prosperityStat = prosperityStat * (1 + (-1 * prosperityBonus));
}
//Debug.Log("new prosperityStat == " + prosperityStat); // test

//Debug.Log(" happinessStat = " + happinessStat + " + happinessBonus = " + happinessBonus); // test
if (happinessStat >= 0)
{
    happinessStat *= (1 + happinessBonus);
}else
{
    happinessStat *= (1 + (-1 * happinessBonus));
}
//Debug.Log("new happinessStat == " + happinessStat); // test

//Debug.Log("environmentStat = " + environmentStat + " + environmentBonus = " + environmentBonus); // test
if (environmentStat >= 0)
{
    environmentStat *= (1 + environmentBonus);
}else
{
    environmentStat *= (1 + (-1 * environmentBonus));
}
//Debug.Log("new environmentStat == " + environmentStat); // test
*/